# 面试题
## 1. javascipt的原始数类型
JavaScript的原始数据类型有：Number,Null,String, Boolean,undenfined,symbol。
* symbol是es6新增的数据类型，表示独一无二的。
原始类型存储的都是值，是没有函数可以调用的。给原始数据类型调用方法是因为js将其隐式转换了，原始数据类型在使用方法的时候，数据类型已经不是原始数据类型了。

## 2. typeof 和 instanceof的区别
typeof 可以判断原始数据基本类型，出来null以外，其他的都可以判断。typeof 判断对象时，除了函数可以判断外其他都无法判断，返回的都是object。
instanceof 是通过原型链的方式判断数据类型的，所以可以判断对象数据类型，但是无法准确判断原始数据类型。

## 3. js中哪些数据是false
undefined null false NaN '' 0 -0

## 4. == 和 === 的区别
== 两者类型不一样时会进行类型转换
=== 会比较两者的类型和数值。

## 5. 闭包
函数A里面有个函数B，函数B可以访问函数A里面的变量，函数B就是闭包。

## 6. forEach Map filter find findOf reduce some
forEach 对数值进行变量
Map 变量数组，对每个数据进行出来，返回一个新数组
filter 对数组进行过滤，将满足条件的数据筛选出来，返回一个新数组
find 找出第一个满足条件的值
findOf 找出第一个满足条件值的索引
reduce 对数组内的值进行累加，返回最后一个值
some 对数组进行遍历，如果有满足条件的值就返回true，否则返回false。

## 7. 并行和并发
并发是同时发布多条任务，但始终只有一条任务在执行。
并行的同时发布多头任务，所有任务同时执行。
表面上来看，并行比并发好，但是并行会因为硬件影响并行的数量，一旦并行达到顶峰，就会造成堵塞。
并发因为始终只有一条任务。所以不会造成堵塞，但并发的效率比并行低。

## 8. new 操作符干了什么
创建一个新对象
将this指向该新对象
执行构造函数里面的代码
返回这个新对象

## 9. 为什么使用Object.create(null)创建对象
Object.create(null) 创建的对象没有任何的继承，并且原型上的属性和方法都被抛弃了。

## 10. cookie localStorage sessionStorage indexDB
cookie 大小4kb 一般在服务器和浏览器之间传递数据，携带token。有销毁时间的。
localStorage 大小20m 用来在本地存储数据，不清理不会消失。可以在不同的网页之间读取。
sessionStorage 大小5m 用来在本地存储数据，关闭页面就会消失。不可以在不同的网页之间读取。
indexDB  用不完 用来存储网页上的数据，信息和提示，不清理不会消失。

## 11. 浏览器的渲染机制
浏览器拿到html和css是怎么处理的？
1. 浏览器拿到html时，会根据词法分析，将其转换为标记（token）,下一步是将标记转换为节点(node),最后根据这些节点的不同关系转换为DOM树(结构树)。
2. 浏览器拿到css时，也和html差不多，先转换为标记，再转换为节点。最后构建CSSOM树（样式树）。
```css
*{font-size: 12px;}
/* 通配符添加样式的时候，会遍历页面上的所有标签，然后添加样式，极其消耗性能 */

div{font-size: 12px;}
/* 标签添加样式的时候会遍历所有的div，再添加样式 */

p span a {font-size: 12px;}
/* 后代选择器添加样式的时候会遍历所有的a标签，再它的父标签里面找span, 再向上找p,最后找符合条件的标签上添加样式*/

p>span>.btn{color:res;}
/* 子代选择器添加样式会先遍历所里类btn标签，再到它父标签里面找sppn,再向上找p，最后找符合条件的标签上添加样式 */

#btn{color: red;}
/* 之间再页面上找id为btn的标签，添加样式，性能销毁最小 */
```
3. 当两棵树渲染完成后开始生成渲染树，生成渲染树是非常消耗性能的。
* 每一次重新添加样式，都会导致部分结构树重新渲染。
* 每一个标签上的display:none 都不会渲染该节点。
* 每一次的重新渲染都会递归DOM树和CSSOM树。
4. 页面渲染完成后，修改页面的结构或样式的时候，页面会有两种情况
* 重绘：修改页面样式而不影响布局的，比如修改background-color。就叫重绘
* 回流： 修改布局或几何样式的，就叫重绘。
回应一定导致重绘，重绘不一定导致回流。会流的成本比重绘高，修改父节点里面的子节点的，很可能会导致父节点的一系列回流。
下面的一些操作可能会导致回流
修改盒子大小
修改盒模型
添加删除样式
添加删除标签
修改字体
改变文字内容
定位或浮动
获取宽高
减少回流的操作：减少css的transform操作，减少display的操作，样式渲染时会从右到左查找，减少书写的层级。

## 12. 箭头函数
箭头函数的内部不考虑this指向，外部环境指向什么就指向什么。箭头函数没有arguments,supper等方法。
箭头函数用在适合使用匿名函数的地方，并且它们不能做为构造函数。 

## 13. 伪数组转真数组
```js
// 1
let arr = { 0: "a", 1: "b", 2: "c", length: 3 };
let newArr = [].slice.call(arr)
console.log(newArr)
// 2
Array.from()
console.log(Array.from(arr))
```
## 14. 防抖与节流
什么是防抖？
当事件被触发后，延迟n秒后再执行回调，如果再这n秒内事件又被触发了，则重新计时。就称为防抖策略。
防抖中事件最终只被触发一次。可以有效减少请求次数，节约请求资源。
防抖的原理是在事件时间的作用范围内，又触发事件的时候，请除上一次定时器，重新开启定时器。
```js
<input type="text" id="ipt" >
<script>
    let ipt = document.querySelector('#ipt')
    var time = null
    ipt.addEventListener('input',function(e) {
        clearTimeout(time)
        time = setTimeout(() => {
            console.log(e.target.value)
        }, 1000);
    })
</script>
```
什么是节流？减少一段事件内事件的触发频率。
```js
<button id="btn">点击</button>
var btn = document.querySelector('#btn')
var firstime = ''
var timer = 1000
btn.addEventListener('click', function() {
//    var firstime
    var lasttime = Date.now()
    if (lasttime - firstime >= timer) {
        console.log('boom');
        firstime = lasttime
    }
})
```
节流和防抖的区别
如果事件频繁触发，防抖能保证最后一个事件被触发，前面的事件都被忽略。
如果事件频发触发，节流能减少事件触发频率，因此，节流是选择性的触发部分事件。

## 15. 移动端 1px
在实际开发中，手机端写1px像素的线条看上去会比实际上粗一点。每个手机厂商的1px都是不一样的。
解决方案是 transform.scale(0.5) 缩放线条宽度

## 16. 判断一个属性是否在对象本身，而不是在原型上
```js
function hasOwn(arr,key) {
    return Object.prototype.hasOwnPrototype.call(obj,key)
    // 在对象本身则返回true 在原型上则返回false
}
```
## 17. let,var,const的区别
* let,const 有块级作用域和暂时性死区
* let const不存在变量提升,var有变量提升
* const 声明时必须赋值，而且不能更改。
* var 全局声明的会挂载到window，let,const 不会
* let,const不允许重复声明
## 18. Promise
Promise是一个构造函数，接收一个参数是函数，并且传入两个参数resolve,reject。resolve表示异步操作执行成功后的回调函数，reject表示异步操作执行失败后的回调函数。身上还有all,race方法。在原型上还有then，catch方法。
在new Promise时会执行里面的代码，因此我们一般包在函数，使用的时候在调用。
Promise的作用是：把回调函数分离处理，在异步操作执行完成后，再链式调用回调函数。简化了层层回调的写法。
再then中可以写两个参数，一个是执行成功的回调函数，提高是执行失败的回调函数。
catch也是用来接收执行失败的的操作。与then的第二个参数的不同点是：如果在执行resolve函数时如果抛出了异常，catch会接收异常，代码会继续执行，而then的第二个参数不会接收异常。会出现报错，代码卡死，不再向下执行。

## 19. 一句话数组去重和数组找最大值
利用的数组的扩展运算符，Set数据结构的特点就是不能有相同的值。
* new Set(...arr)  数组去重
* Math.max(...arr)  找最大值

## 20. 变量的结构赋值
结构赋值的意思的，从数组和对象中提取值，对变量进行赋值。
节点赋值的对象必须是数组或者有可遍历的数据结构。所以字符串和数值都是可以解构的。数组的解构是有顺序的，对象的解构是安装属性对应来说。
ES6内部使用的是严格相等运算符，判断一个位置是否有值，只有当一个数组成员严格等于undefined时，才会等于默认值。

## 21. 查找对应字符串的方法
都有两个参数，第一是要匹配的字符，第二个参数是开始的位置
* includes()  查找是否存在，返回布尔值  数组方法，字符串可以用
* startsWith() 开头匹配，返回布尔值
* endsWidth() 结尾匹配，返回布尔值

find() 找出第一个符合条件的数组成员，找不到返回undefined
findIndex() 找出第一个符合条件的数组的索引，找不到返回-1

## 22. ES6新增方法
下面三个Number方法都不进行隐式转换，不将非数值转换为数值。
* Number.isFinite() 判断一个数值是否有限。
* Number.isNaN() 判断一个值是否为NaN。
* Number.isInteger() 判断一个数值是否为整数。
* Math.trunc() 方法用于去除一个数的小数部分，返回整数部分。
* Math.sing() 用于判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
* Array.form() 可以将伪数组或遍历对象转换为真正的数值

## 23. 函数的默认传参
ES6允许为函数的参数设置默认值，即直接写在参数定义的后面
```js
funciton fn( n = 12) {
    console.log(n)
}
fn()  // 12
fn(15)  // 15
```

## 24. ES5方法
Object.is() 比较两个值是否相等， == 和=== 都有缺点， == 会进行隐式转换，=== 中NaN不等于NaN,+0等于-0
Object.is(NaN,NaN) // true
Object.is(+0,-0) // false
Object.assign 用于对象的合并

## 25. async
async是ES6提供的Promise语法糖，得到的是resolve返回的值。

## 26. module
ES6提供了模块的概念，我们可以使用模块引用的方法引用模块，模块功能主要由两个命令构成：export 和 import。export命名用于规定模块对外的接口，import命令用于其他模块提供的功能
export用于导出变量，但使用module.export导出只能使用一次
```js
let num = 100
let obj = {}
let arr = []
let func = function() {}
export {num, obj, arr, func} 
// 可以使用as重命名
export {
    num as myNum,
    obj as myObj,
    arr as myArr,
    func as myFunc
    }
```
使用exprot命名定义模块的对外接口以后，其他js文件就可以通过import命名加载这个模块
```js
import {myNum, myObj, myArr, myFunc} from 'index.js'
import index from 'index.js'
```
ES6模块与CommonJS模块的差异
* CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用
* CommonJS模块是运行时加载，ES6模块是编译时输出接口

## 27. Vue里面computed是什么东西怎么用？
在Vue模板里面使用表达式是非常变量的，但是设计它们的初衷是用来简单运算的。在实际开发过程中模板里面放入过多的表达式会让项目可维护性大大降低。对于这种复杂的计算，我们就需要用到计算属性了。计算属性中的方法是依赖其中(data中)值的。当计算属性中的值发生变化的时候，计算属性也会更新。计算属性调用时不加小括号

## 28. Vue里面watch是什么东西怎么使用
虽然计算属性在大部分情况下都适用，但当需要在执行异步或者一些开销比较大的操作中，监听器会比计算属性更加有效。
1. watch 和computed 的区别
计算属性和监听器都是希望在依赖数据发送变化的时候，被依赖的数据根据事先设定好的函数发送自动的变换。
watch 一个数据响应多个数据。
computed 一个数据受到多个数据的响应。
在实现原理上watch 和computed是差不多的，vue的data值在初始化阶段都被挂载上watcher观察者模式，当数据改变的时候会先调用watcher观察者模式，然后调用计算属性和监听器，本质上没有多大区别。
## 29. Vue-router有哪几种导航钩子
vue一共有三种导航钩子，分为全局钩子、路由独享钩子、组件内导航钩子
1. 全局钩子分有三种，是前置守卫，后置钩子，全局解析钩子。
前置守卫 router.beforeEach
后置守卫 router.afterEach
解析守卫 router.beforeResolve
其中解析守卫是在2.5版本中新增加的，解析和beforeEach类似，区别是：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。
2. 路由独享钩子，即单个路由独享的导航钩子，他是在路由配置上直接定义的
```js
const router = new VueRouter({
    routes: [
        {
        path: '/file',
        component: File,
        beforeEnter: (to,from,next) => {
            // do someting
        }
        }
    ]
})
```
3.  组件内的导航钩子主要有三种：beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave。他们是直接在路由组件内部直接定义的。
```js
const File = { 
    template: `
    <div>This is file</div>
    `,
    beforeRouteEnter(to,from,next) {
        // do something    在渲染该组件的对应路由被confirm前调用
    },
    beforeRouteUpdate(to, from,next) {
        // do something  在当前路由改变，但依然渲染该组件时调用
    },
    beforeRouteLeave(to, from,next) {
        // do something  导航离开该组件的对应路由时被调用
    }
 }
```
## 29. 导航解析流程说一下
1. 导航被触发
2. 在失活的组件里调用离开守卫
3. 调用全局的beforeEach守卫
4. 在重用的组件里调用beforeRouteUpdate守卫
5. 在路由配置调用beforeEnter
6. 解析异步路由组件
7. 在被激活的组件里调用beforeRouteEnter
8. 调用全局的beforeResolve钩子
9. 导航被确认
10. 调用全局的afterEach钩子
11. 触发DOM更新
12. 在创建好的实例调用beforeRouteEnter守卫中传给next的回调函数

## 30. Vue的核心是什么？
Vue的核心主要包含两点：响应式驱动和组件系统。
1. 其中响应式驱动，就是建立在es5的一个方法Object.defineProperty和寄存器getter和setting方法实现的一种设计模型，观察者和订阅者模式。也可以称为基于依赖收集的观测机制，其中他们的核心就是VM(mvvm)视图和数据的双向绑定。
2. 组件系统的核心就是模块，初始化数据，接收外部传参，方法，生命钩子函数，私有资源。

## 31. 组件是什么？模块是什么？
在实际的开关过程中，通常有两个开发模式，组件开发和模块化开发。
1. 组件化：侧重于业务的解耦，根据页面中的业务逻辑进行划分组件
2. 模块化：侧重于重用，根据页面中的功能进行划分成模块。

## 32. axios
axios是一个基于promise的HTTP库，可以用在浏览器和node.js中
axios为什么不能在IE9浏览器使用，是因为axios中使用很多es6的方法，所以axios需要转换一下才可以使用。安装babel-polyfill 和 es6-promise插件就可以解决了。
axios是不支持jsonp的要么让后台使用cors插件，要么自己写个后台，进行反向代理。

## 33. Node中模块化
1. 什么是模块化？
模块化是值解决一个复杂问题时，自顶向下逐层`把系统划分成若干模块的过程`，对于整个系统来说，模块是可组合，分解和更换的单元。
2. 编程领域的模块化
编程领域的模块化，就是遵守固定的规则，把一个大文件拆分为独立并相互依赖的多个小模块。
3. 把代码进行模块化拆分的好处
提高了代码的复用性。
提高了代码的可维护性。
可以实现按需加载。
4. 模块化的分类
分为三类，内置模块，node官方提供的。自定义模块，用户创建的每个js文件都是。第三方模块，第三方开发出来的模块。
5. 模块作用域
和函数作用域类似，在自定义模块中定义的变量，方法等成员，`自能在当前模块内被访问`，这种模块级别的访问限制就是模块作用域。
模块作用域的好处是防止全局变量污染的问题
5. require() 导入
使用require() 方法导入时，导入的结果，永远以module.exports指向的`对象`为准。因为返回的都是对象形式的，使用最后module.exports暴露数据时，如果最后一个是对象形式，就会把前面的返回值覆盖，如果不是就会向里面添加。
但是，最好只使用一个module.exports向往暴露数据。
* 默认情况下exports和module.exports指向同一个对象，最终共享的结果，还是以module.exports指向的`对象` 为准。

## 34. CommonJS
Node遵循了CommonJS模块化规则，Commonjs规则了模块的特性和各个模块之间如何相互依赖。
CommonJS规
* 每个模块内部，module变量代表当前模块
* module变量是一个对象，它的exports属性(即module.exports)是对外的接口
* 加载某个模块，其实是加载该模块的module.exports属性。require()方法用于加载模块
## 35. npm包安装的节点
1. 开发依赖包
如果只是在开发阶段会用到，项目上下之后不会用到，则把包记录到devDependencies节点
```js
// 安装指定的包，并记录到devDependencies节点
简写： npm i 包名 -D
完整写法：npm install 包名 --save-dev
```
2.核心依赖包 
如果在开发和上线后都会用到，则把包记录到dependencies节点中 
npm i 包名 或者 npm i 包名 -S
## 35. 包的规范
包的规范在组件必须符合一下3点要求：
1. 包必须以单独的目录而存在的
2. 包的顶级目录下必须包含package.json这个包管理配置文件
3. package.json中必须包含name,version,main 这三个属性，分别代表包的名字、版本号、包的入口。
## 36. 开发属于自己的包
1. 初始值包的基本解构
新建dawuhuang 文件夹，做为`包的根目录`。在里面新建如下三个文件
package.json(包管理配置文件)
index.js(包入口文件)
README.md(包的说明文档)

## 36. 模块的加载机制
模块第一次加载会被缓存。这也意味着多次调用require()不会导致模块的代码被执行多次。它们都会优先从缓存中加载，从而提高模块的加载效率。
1. 内置模块的加载优先级最高。

2. 自定义模块的加载机制
使用 require() 加载自定义模块时，必须指定以 ./ 或者 ../ 开头的`路径标识符`，在加载自定义模块时，如果没有指定 ./ 或者 ../ 这样的路径标识符，则node会把它当中内置模块或者第三方模块进行加载。
同时在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则Node.js 会按顺序分别尝试加载一下文件
* 按照确切的文件名进行加载
* 补全.js扩展名进行加载
* 补全.json扩展名进行加载
* 补全.node扩展名进行加载
* 加载失败，终端报错
3. 第三方模块的加载机制

使用 require() 加载自定义模块时，如果没有指定 ./ 或者 ../ 这样的路径标识符，则node会把它当中内置模块或者第三方模块进行加载。
`如果没有找到对应的第三方模块，则移动到再上一级父目录中，进行加载，指导文件系统的根目录`
假设，在'C:\U\J\P\foo.js'文件里面调用了require('tools')，则Node.js会按照以下顺序进行查找
* C:\U\J\P\node_modules\tools
* C:\U\J\node_modules\tools
* C:\U\node_modules\tools
* C:\node_modules\tools

4. `目录`作为模块
当把目录当中模块标识符，传递给require()进行加载的时候，有三种加载方式:
* 被加载的目录下查找一个叫做package.json的文件，并寻找main属性，作为 require() 加载的入口。
* 如果目录里没有package.json文件，或者 main 入口不存在或无法解析，则Node.js 将会视图加载目录下的index.js.
* 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺少: Error:Cannot find module 'xxx'

## 37. express
1. 获取URL中携带的查询参数
客户都使用?name=zs&age=20这种查询字符串，可以通过req.query对象访问到。例如: req.query.name   req.query.age
2. 获取URL中的动态参数
```js
// URL地址中可以通过 :参数名 的形式，匹配动态参数值
app.get('/user/:id',(req,res) => {
    // req.params默认是一个空对象，里面存放着通过 : 动态匹配到的参赛值
    consoloe.log(req.params)  // {id: 3}
})

```
3. 静态资源托管 express.static()  如果要托管多个静态资源，就多次调用express.static()
4. 挂载`路径前缀` 
如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方法
```js
app.use('/public',express.static('public))
//  http://localhost:3000/public/index.js 
```
## 38. 路由
路由就是映射关系。在 express 中，路由指的是客户端的请求与服务器端处理函数之间的映射关系
Express中的路由分3部分组成，分别是请求的类型，请求的URL地址、处理函数
app.METHOD(PATH, HANDLER)
每当一个请求到达服务之后，需要先经过路由的匹配，只有(请求类型和请求的URL)匹配成功之后，才会调用处理函数。

## 38. 模块化路由
为了方便对路由进行模块化管理，Express不建议将路由直接挂载到app上，而是推荐将路由单独抽离为模块，步骤如下：
1. 创建路由模块对应的.js文件
2. 调用express.Router()函数创建路由对象
3. 向路由对象上挂载具体的路由
4. 使用module.express向外共享路由对象
5. 使用app.use()函数注册路由模块

## 39. 中间件
中间件特指业务流程的中间处理环节。当一个请求到达Express的服务器之后，可以连续调用多个中间件，从而对这次请求进行`预处理`。
Express的中间件，本质上就是function处理函数，中间件的形参列表中，必须包含next参数，而路由处理函数中只包含req和res。
使用时注意事项：
1. 一定要在路由之前注册中间件
2. 客户发送过来的请求，可以连续调用多个中间件进行处理
3. 执行完中间件的业务代码之后，不要忘记调用next()函数
4. 为了防止代码逻辑混乱，调用next()函数后不要再写额外的代码
5. 连续调用多个中间件时，多个中间件之前，共享req和res对象。 

## 40. 中间件的分类
为了方法大家理解和记忆中间件的使用，Express官方把常见的中间件，分成了5大类，分别是：
1. 应用级别的中间件
通过app.use() 或者app.METHOD()函数(如app.get()、app.post())，绑定到app实例上的中间件，叫做应用级别的中间件。
2. 路由级别的中间件
绑定到express.Router()实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何的区别，只不过，应用级别中间件是绑定到app实例上的，路由级别中间件是绑定到router实例上
3. 错误级别的中间件
错误级别的中间件function处理函数，必须有4个形参，形参顺序从前到后，分别是(err,req,res,next)。
错误级别的中间件：`必须注册在所以路由之后`
```js
app.get('/',function(req,res) {              // 1.路由
    throw new Error('服务器内部发生了错误')    // 1.1 抛出一个自定义的错误
    res.send('heome page')
})
app.use(function(err,req,res,next) {          // 2.错误级别的中间件
    console.log('发生了错误：' + err.message)  // 2.1 在服务器打印错误消息
    res.send('Error！' + err.message)         // 2.2 向客户都响应错误消息的内容
})
```
4. Express内置的中间件内置3个常用的中间件
* express.static 快速托管静态资源的内置中间件。例如 HTML文件、图片、css样式等(无兼容性)
* express.json 解析JSON格式的请求体数据(有兼容性,仅在4.16.0+版本中可以)
```js
// 配置解析 application/json格式数据的内置中间件
app.use(express.json())
```
* express.urlencoded解析URL-encoded格式的请求提数据(有兼容性，仅在4.16.0+版本中可用)
```js
// 配置解析：application/x-www-form-urlencoded 格式数据的内置中间件
app.use(express.urlencoded({extended:false}))
```
5. 第三方的中间件
非Express官方内置的中间件，而是由第三方开发出来的Express中间件,叫做第三方中间件。例如，除了使用express.urlencoded这个内置中间件来解析请求体数据，还可以使用body-parser这个第三方中间件。来解析请求提数据。express.urlencoded中间件就是根据body-parser的进一步封装。















































































## Proxy
## class 类
## 手写一个Promise
## Vue双向数据绑定的原理